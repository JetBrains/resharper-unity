<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.RdCore35</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Util.EmptyArray`1">
            <summary>
            Reuses the single instance of an empty array (one per type). If possible, prefer <see cref="!:EmptyList&lt;T&gt;.InstanceList"/>
            because each time you enumerate empty array, new <see cref="!:Array.SZArrayEnumerator"/> class instance is being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray">
            <summary>
            Reuses the single instance of an empty array (one per type).
            This class is preferrable over <see cref="!:EmptyList&lt;T&gt;"/> when you'd like to use SmartCompletion for completing the array type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.EmptyArray.GetInstance``1">
            <summary>Synonym for <see cref="F:JetBrains.Util.EmptyArray`1.Instance"/></summary>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.ExtractOrBlock">
            <summary>
            Returns first element from queue or waits until it appears. In case of lifetime termination throws PCE.
            </summary>
            <returns>First element in queue</returns>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item and returns the total number of items in the queue right after enqueueing, in a thread-safe-consistent manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.src.dataStructures.BlockingPriorityQueue`1.ToArray">
            <summary>
            Copies data to an array, thread-safely.
            </summary>
        </member>
        <member name="F:JetBrains.Util.MethodImplAdvancedOptions.AggressiveInlining">
            <summary>
            Corresponds to <code>MethodImplOptions.AggressiveInlining</code> value in 4.5 framework. This value is just swallowed in lower frameworks
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.LogLog">
            <summary>
            To record messages and exceptions from logger (and logger referenced code) and don't fall into infinite recursion.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.LogLog.MaxRecordsToStore">
            <summary>
            Sliding window of records
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.LogLog.StoredRecords">
            <summary>
            We store last <see cref="F:JetBrains.Util.Logging.LogLog.MaxRecordsToStore"/> loglog records to browse
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.FATAL">
            <summary>
            For errors that are 
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debbuging
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.Util.Monad.Result">
            <summary>
            Helper methods for <see cref="T:JetBrains.Util.Monad.Result`1" /> and <see cref="T:JetBrains.Util.Monad.Result`2"/> building
            </summary>
        </member>
        <member name="F:JetBrains.Util.Monad.Result.EmptyFailMessage">
            <summary>
            Message that is being applied to Result.Fail when no message provided 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Success``1(``0)">
            <summary>
            Creates successful <see cref="T:JetBrains.Util.Monad.Result`1"/> with value <see cref="!:value"/>
            </summary>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> == true</returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Fail(System.Exception)">
            <summary>
            Creates failed <see cref="T:JetBrains.Util.Monad.Result`1"/>
            </summary>
            <param name="exception"></param>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Fail``1(System.Exception,``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Util.Monad.Result`2"/> with corresponding <see cref="!:failValue"/>
            </summary>
            <param name="exception"></param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`2.Success"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`2"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Fail(System.String)">
            <summary>
            Creates failed <see cref="T:JetBrains.Util.Monad.Result`1"/> with <see cref="T:System.InvalidOperationException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Util.Monad.Result.EmptyFailMessage"/> is used.</param>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Fail``1(System.String,``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Util.Monad.Result`2"/> with <see cref="T:System.InvalidOperationException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Util.Monad.Result.EmptyFailMessage"/> is used.</param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`2.Success"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.FailWithValue``1(``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Util.Monad.Result`1"/> with message= <see cref="F:JetBrains.Util.Monad.Result.EmptyFailMessage"/> and user-defined failure parameter 
            </summary>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`2.Success"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Canceled">
            <summary>
            Creates special failed <see cref="T:JetBrains.Util.Monad.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <returns>Result with <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> == false and <see cref="P:JetBrains.Util.Monad.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Util.Monad.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Wrap``1(System.Func{``0})">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Util.Monad.Result`1"/>. 
            </summary>
            <param name="f">Function  to execute</param>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Util.Monad.Result`1.Value"/> == f() if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result.Wrap``2(System.Func{``0,``1},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Util.Monad.Result`1"/>. 
            </summary>
            <param name="f">Function with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed eesult with <see cref="F:JetBrains.Util.Monad.Result`1.Value"/> == f(param) if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="T:JetBrains.Util.Monad.Result`1">
            <summary>
            Monad that can can have two states: <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> and Fail (!<see cref="P:JetBrains.Util.Monad.Result`1.Success"/>). Also we distinct special type of Fail: <see cref="P:JetBrains.Util.Monad.Result`1.Canceled"/>.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:JetBrains.Util.Monad.Result`1.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Util.Monad.Result`1.Success"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Util.Monad.Result`1.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Util.Monad.Result`1.Success"/>), null otherwise
            </summary>
        </member>
        <member name="P:JetBrains.Util.Monad.Result`1.FailMessage">
            <summary>
            Exception message in case of (!<see cref="P:JetBrains.Util.Monad.Result`1.Success"/>), null otherwise 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Monad.Result`1.#ctor(`0,System.Exception)">
            <summary>
            Shouldn't be invoked in user's code
            </summary>
            <param name="success"></param>
            <param name="failure"></param>
        </member>
        <member name="P:JetBrains.Util.Monad.Result`1.Success">
            <summary>
            !<see cref="P:JetBrains.Util.Monad.Result`1.Success"/> and <see cref="P:JetBrains.Util.Monad.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Monad.Result`1.FailedNotCanceled">
            <summary>
            (!<see cref="P:JetBrains.Util.Monad.Result`1.Success"/>) and (<see cref="P:JetBrains.Util.Monad.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Monad.Result`1.Canceled">
            <summary>
            Exception has specials type of <see cref="T:System.OperationCanceledException"/> or <see cref="!:AggregateException"/> that has <see cref="T:System.OperationCanceledException"/> inside.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Monad.Result`1.Map``1(System.Func{`0,``0})">
            <summary>
            Transform this result into new one with given function. if !<see cref="P:JetBrains.Util.Monad.Result`1.Success"/>, stays untouched./> 
            </summary>
            <param name="transform"></param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Monad.Result`1.Unwrap">
            <summary>
            Returns <see cref="F:JetBrains.Util.Monad.Result`1.Value"/> if <see cref="P:JetBrains.Util.Monad.Result`1.Success"/>, throws <see cref="F:JetBrains.Util.Monad.Result`1.Exception"/> otherwise
            </summary>
            <returns> <see cref="F:JetBrains.Util.Monad.Result`1.Value"/> if <see cref="P:JetBrains.Util.Monad.Result`1.Success"/> </returns>
            <exception cref="F:JetBrains.Util.Monad.Result`1.Exception">if !<see cref="P:JetBrains.Util.Monad.Result`1.Success"/></exception>
        </member>
        <member name="T:JetBrains.Util.Monad.Result`2">
            <summary>
            Special kind of <see cref="T:JetBrains.Util.Monad.Result`1"/> to store custom <see cref="F:JetBrains.Util.Monad.Result`2.FailValue"/> in case of !<see cref="P:JetBrains.Util.Monad.Result`2.Success"/>. 
            </summary>
            <typeparam name="TSuccess"></typeparam>
            <typeparam name="TFailure"></typeparam>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReader.ReadCollection``2(JetBrains.Util.PersistentMap.UnsafeReader.ReadDelegate{``0},System.Func{System.Int32,``1})">
            <summary>
            Non optimal collection serialization. One can serialize internal structure (eg. array) instead.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCol"></typeparam>
            <param name="ptr"></param>
            <param name="readDelegate"></param>
            <param name="contructor"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.Cookie.WriteIntLengthToCookieStart">
            <summary>
            Writes `<see cref="P:JetBrains.Util.PersistentMap.UnsafeWriter.Cookie.Count"/><c> - sizeof(int)</c>` into the <see cref="P:JetBrains.Util.PersistentMap.UnsafeWriter.Cookie.Data"/> pointer. Cookie must be prepared by invoking `<see cref="M:JetBrains.Util.PersistentMap.UnsafeWriter.Write(System.Int32)"/><c>(0)</c>` as first cookie call.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.WriteStringContent(System.String)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.WriteStringContent(System.String,System.Int32,System.Int32)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.Alloc(System.Int32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Take the <see cref="P:JetBrains.Util.PersistentMap.UnsafeWriter.Ptr" /> value before calling <see cref="M:JetBrains.Util.PersistentMap.UnsafeWriter.Alloc(System.Int32)" /> to address the space correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriter.Write``2(JetBrains.Util.PersistentMap.UnsafeWriter.WriteDelegate{``0},``1)">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.ByteBufferAsyncProcessor.Start">
            <summary>
            Starts async processing of queue.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.ByteBufferAsyncProcessor.Stop(System.Int32)">
            <summary>
            Gracefull stop. Process queue, but doesn't accept new data via <see cref="M:JetBrains.Util.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. -1 for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Util.Threading.ByteBufferAsyncProcessor.Terminate(System.Int32)">
            <summary>
            Force stop. Doen't process queue, doesn't accept new data via <see cref="M:JetBrains.Util.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. -1 for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="T:JetBrains.Util.Util.RName">
            <summary>
            Recursive name. For constructs like Aaaa.Bbb::CCC
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.RName.Sub(System.String,System.String)">
            <summary>
            Separator doesn't count if localName is empty or parent is empty.
            </summary>
            <param name="localName"></param>
            <param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.Util.Util.Statics">
            <summary>
            Represents global statics in a stack-like way 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Statics.For``1">
            <summary>
            Gets statics holder for type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>Stack-like holder</returns>
        </member>
        <member name="T:JetBrains.Util.Util.Types">
            <summary>
            Extensions to <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Util.Types.ourPrimitives">
            <summary>
            To prettify Int32, Int64 and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Types.ToString(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Different <c>ToString()</c> of <see cref="T:System.Type"/>.
            
            Samples are provide for:  
            <code>
            namespace Foo { 
              class Outer&lt;T1&gt;
              {
                 internal class Inner&lt;T2&gt; {}
              }    
            }
            
            </code>     
            </summary>
            <param name="thisType"><c>typeof(Outer&lt;string&gt;.Inner&lt;int&gt;)</c></param>
            <param name="withNamespaces">if `true` (and <see cref="!:withGenericArguments"/> == `false`) then <c>Foo.Outer+Inner</c> else <c>Outer+Inner</c> </param>
            <param name="withGenericArguments">if `true` (and <see cref="!:withNamespaces"/> == `false`) then <c>Outer&lt;string&gt;+Inner&lt;int&gt;</c> else <c>Outer+Inner</c> </param>
            <returns>More natural than <see cref="M:System.Type.ToString"/> string representation of type</returns>
        </member>
        <member name="T:JetBrains.DataFlow.EternalLifetime">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect.</para>
            <para>Do not call <see cref="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>
            <para>As <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> requires a parent lifetime, the lifetime that has no parent is rooted under <see cref="T:JetBrains.DataFlow.EternalLifetime"/>. Thus, this eternal lifetime is the parent of all the other lifetimes.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EternalLifetime.Instance">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect. Its <see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> always yields <c>False</c>.</para>
            <para>Do not call <see cref="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>
            <para>As <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> requires a parent lifetime, the lifetime that has no parent is rooted under <see cref="T:JetBrains.DataFlow.EternalLifetime"/>. Thus, this eternal lifetime is the parent of all the other lifetimes.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EternalLifetime.Definition">
            <summary>
            <para>The definition of the <see cref="P:JetBrains.DataFlow.EternalLifetime.Instance">eternal lifetime</see>.</para>
            <para>Calling <see cref="M:JetBrains.DataFlow.LifetimeDefinition.Terminate"/> on such a definition is allowed, but has no effect. Its <see cref="P:JetBrains.DataFlow.LifetimeDefinition.IsTerminated"/> always yields <c>False</c>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Lifetime">
            <summary>
            <para>Represents the lifetime of the objects which have an explicit span of life and have actions to be executed upon termination. In that, replaces the <see cref="T:System.IDisposable"/> pattern.</para>
            <para>Objects get their lifetime in constructor and schedule termination actions on it. Instead of calling <see cref="M:System.IDisposable.Dispose"/>, the owner of the object terminates the lifetime it has given to the object with <see cref="M:JetBrains.DataFlow.LifetimeDefinition.Terminate"/>.</para>
            <para> If a function gets lifetime in parameters, the lifetime defines the duration of the effect of the function. For instance, adding an item to the collection under a lifetime means the item should be reclaimed from the collection when the lifetime ends. It is highly recommended to introduce lifetimed functions to APIs instead of pairing <c>Register</c>-<c>Unregister</c> methods, because this has far better guarantees on proper pairing of the activities on part of API users.</para>
            <para>To create a lifetime, use <see cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.Logging.ILog)"/> or its overloads. Usually you should have a parent lifetime (component lifetime, etc) to pass in. You get the <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> object which means that you own this lifetime and can terminate it at your discretion. Take the lifetime itself out of it and pass to owned objects so that they were bound to your lifetime, but could not end it prematurely. In the rare cases when the child object might have its own lifetime considerations (i. e. a user-closeable non-modal dialog), pass the lifetime definition and be ready to handle its termination by the child object.</para>
            <para>If you need a function-scoped lifetime, like the <c>using{}</c> construct for <see cref="T:System.IDisposable"/>, use the <see cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})"/> method.</para>
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.OptionThrowOnSchedullingInTerminated">
            <summary>
            Whether to throw if something it being scheduled on a terminated lifetime.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.OptionRevertSchedulledInTerminated">
            <summary>
            If the actions scheduled on a terminated lifetime should be executed immediately (for actions; brackets are just ignored; disposes are disposed; etc).
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.myItems">
            <summary>
            Stores the items to execute upon termination.
            Access must be synchronized thru <see cref="F:JetBrains.DataFlow.Lifetime.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.myLogger">
            <summary>
            Logging facility for issues reported by this lifetime.
            For example, exceptions in lifetime termination activities should not prevent the rest of activities from being executed; such exceptions are reported to the logging facility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddDispose(System.IDisposable)">
            <summary>
             <para>Schedules an <see cref="T:System.IDisposable"/> object to be disposed of when the lifetime gets terminated.</para>
             <para>Upon termination, scheduled activities are executed in the reverse order (LIFO).</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.ReportTerminatedLifetime(System.String)">
            <summary>
            Throws an exception reporting that we're attempting to schedule on an already-terminated lifetime.
            Adds lifetime ID if available.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddAction(System.Action)">
            <summary>
             <para>Schedules an <see cref="T:System.Action"/> to be executed of when the lifetime gets terminated.</para>
             <para>Upon termination, scheduled activities are executed in the reverse order (LIFO).</para>
             <para>Fluent.</para>
            </summary>
             <remarks>
             <para>Throws an exception if the lifetime has already been terminated.</para>
             <para>Thus, take care in free-threaded scenarios: the lifetime might get terminated between your check for <see cref="P:JetBrains.DataFlow.Lifetime.IsTerminated"/> and this method's execution.</para>
             <para>For free-threaded code, you should either use the SynchronizedLifetime
              pattern (preferred), or try creating a nested lifetime with <see cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.Logging.ILog)"/> instead, doing all the sensitive operations in its atomic function parameter. This way the atomic action will either be added to a lifetime in a safe way, or executed immediately if it's been terminated already.</para>
             </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddBracket(System.Action,System.Action)">
            <summary>
             <para>Opens a bracket of actions on the lifetime. The opening one is executed immediately, and the closing one executes when the lifetime gets terminated.</para>
             <para>All of the brackets added on the same lifetime are properly nested, as if on a stack (LIFO).</para>
             <para>Fluent.</para>
            </summary>
             <remarks>
             <para>This method is roughly equivalent to writing an opening action contents in the code and doing <see cref="M:JetBrains.DataFlow.Lifetime.AddAction(System.Action)"/> for the closing one.</para>
             <para>Its use is to visually highlight two groups of statements, one being an “undo sequence” for another, which helps with treating them as a solid group when reading or refactoring the code.</para>
             </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AddRef(System.Object)">
            <summary>
             <para>Keeps the <paramref name="object"/> alive and prevents it from being garbage collected for the duration of the lifetime.</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)">
            <summary>
            Nests one lifetime within another.
            The difference with just adding an action for terminating the nested lifetime to the parent lifetime is that with repeated use of short-lived nested lifetimes such actions will grow limitlessly within the parent lifetime.
            This method cleans up the parent lifetime's schedule for terminating the nested lifetime whenever the nested lifetime terminates prematurely.
            Internal: use methods like <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> to define lifetimes nested in other ones.
            </summary>
            <param name="defNested">The nested lifetime to be attached to this lifetime.</param>
            <param name="isPossiblyAlreadyTerminated">Whether the nested lifetime could be expected to be terminated by smb. Possible cases: <see cref="!:Lifetimes.Define(JetBrains.DataFlow.Lifetime,string,System.Action&lt;JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime&gt;)"/> in whose atomic action the nested lifetime is scheduled for termination on another thread. In such a case the caller check if the nested has been terminated doesn't help because the termination occurs async. Without this flag, it's an error to pass in a terminated lifetime. With this flag, it's silently ignored. Anyway, the behavior is thread-safe.</param>
        </member>
        <member name="P:JetBrains.DataFlow.Lifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetime.Terminate">
            <summary>
             Terminates this lifetime. For calling by <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> only.
             Only an owner of <see cref="T:JetBrains.DataFlow.LifetimeDefinition"/> is allowed to terminate a lifetime.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:JetBrains.DataFlow.Lifetime.Eternal">
            <summary>
            The instance of the eternal lifetime object. Get thru <see cref="T:JetBrains.DataFlow.EternalLifetime"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.LifetimeDefinition">
            <summary>
            <para>An interface to the lifetime that only lifetime owner has. Allows to terminate the lifetime.</para>
            <para>Take the <see cref="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime"/> property value to pass to methods or child objects that need the lifetime, or schedule any actions on it.</para>
            </summary>
            <remarks>
            <para>The <see cref="T:JetBrains.DataFlow.Lifetime"/> interface itself allows to schedule actions on the lifetime, but does not allow to terminate it, because it has been defined by the owner and only owner knows when to end the lifetime.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeDefinition.Terminate">
            <summary>
            Terminates the lifetime. All of the actions and disposes scheduled on this lifetime are executed,
            and all nested lifetimes are terminated. These activities are performed in the reverse scheduled order,
            so that the last entry scheduled is executed first (LIFO).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.LifetimeDefinition.IsTerminated">
            <summary>
            Gets whether this lifetime has already been terminated.
            It's an error to continue scheduling on a terminated lifetime.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime">
            <summary>
            Gets the lifetime defined by this instance.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Lifetimes">
            <summary>
            <see cref="T:JetBrains.DataFlow.Lifetime" />s factory.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection(JetBrains.DataFlow.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection(JetBrains.Util.Logging.ILog,JetBrains.DataFlow.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection2(JetBrains.DataFlow.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.CreateIntersection2(JetBrains.Util.Logging.ILog,JetBrains.DataFlow.Lifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.Logging.ILog)">
            <summary>
              <para>Defines a new lifetime nested within the <paramref name="lifetime" /> you pass in.</para>
            </summary>
            <remarks>
              <para>In most cases, you should have some lifetime to use as a parent, such as the lifetime of your component. If this is not the case, and you just need a function-scoped lifetime, call <see cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})" /> instead. It is terminated automatically when your action ends and thus does not need a parent.</para>
              <para>If the lifetime you're created is really not parented by any other lifetime, use the <see cref="T:JetBrains.DataFlow.EternalLifetime" /> as a parent.</para>
            </remarks>
            <param name="lifetime">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="id">
              <para>Optional. The ID of the lifetime.</para>
              <para>Used for tracking and debugging. If the call stack annotations feature is ON, this ID will appear on the call stack when the lifetime object starts executing schedulled actions upon termination.</para>
              <para>In case of nested lifetimes and if schedulled actions are anonimous in their nature, it might be hard to tell what's happening from exception stack traces without this annotation. You're encouraged to specify IDs wherever such situations are suspected, but the IDs should better be statically defined (to avoid memory leaks on part of the call stacks annotation engine).</para>
              <para>If omitted, the default <see cref="F:JetBrains.DataFlow.Lifetimes.AnonymousLifetimeId" /> or the <see cref="T:JetBrains.DataFlow.Lifetime" /> should type name is used, depending on the context.</para>
            </param>
            <param name="FAtomic">
              <para>Optional. The code to be executed atomically on the newly-created lifetime.</para>
              <para>If this code succeeds (or is not specified), the definition of the new lifetime is returned from the method.</para>
              <para>If this code fails with an exception, the newly-created lifetime is terminated, all of the schedulled actions are executed (rolling back any activities already bound to the lifetime), the nested lifetime is not registered no the parent, and the exception is let out of this method.</para>
            </param>
            <param name="logger">
              <para>Optional logging facility override for the new lifetime.</para>
              <para>For example, exceptions in lifetime termination activities should not prevent the rest of activities from being executed; such exceptions are reported to the logging facility.</para>
            </param>
            <returns>
              <para>The definition to the new lifetime.</para>
              <para>As you own the lifetime, you can terminate it through this defintion at any time.</para>
              <para>To pass the lifetime to objects&amp;functions or schedulle termination actions on it, get it from the <see cref="P:JetBrains.DataFlow.LifetimeDefinition.Lifetime" /> property. Do not pass the definition itself to child objects, unless this is the intended scenario to allow them to terminate the lifetime upon their discretion (e. g. a user-cancelable non-modal dialog).</para>
            </returns>
            <seealso cref="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})" />
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.OuterLifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.Logging.ILog)">
            <summary>
              <para>See documentation on an overload which takes a <see cref="T:JetBrains.DataFlow.Lifetime" />.</para>
            </summary>
            <seealso cref="M:JetBrains.DataFlow.Lifetimes.Define(JetBrains.DataFlow.Lifetime,System.String,System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime},JetBrains.Util.Logging.ILog)" />
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Synchronize(JetBrains.DataFlow.LifetimeDefinition[])">
            <summary>
            Synchronizes termination of two lifetime definitions.
            Whenever any one is terminated, the other will be terminated also.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using(System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using(JetBrains.DataFlow.Lifetime,System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="λ" />with a new lifetime nested within a the <paramref name="parent" /> lifetime you pass in.</para>
              <para>Created lifetime is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
            </summary>
            <param name="parent">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using``1(System.Func{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Lifetimes.Using``1(JetBrains.DataFlow.Lifetime,System.Func{JetBrains.DataFlow.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="λ" /> with a lifetime that is terminated automatically when <paramref name="λ" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">
              <para>The parent lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </param>
            <param name="λ">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="T:JetBrains.DataFlow.OuterLifetime">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.DataFlow.Lifetime" /> interface with which you cannot “bind” actions to a lifetime.</para>
              <para>It's “outer” in the sense that it's not your lifetime, but of some parent object potentially more long-lived than yours. You cannot schedule anything to its termination because it will happen way after your object goes off scope.</para>
              <para>The only thing you can know is that it's an “outer”, it's limiting the life of your object, and if it's terminated — so are you. Checking for <see cref="P:JetBrains.DataFlow.OuterLifetime.IsTerminated" /> is one of the allowed option.</para>
              <para>Another option is to define a nested lifetime, in which case you MUST ensure it's terminated explicitly, without relying on the outer lifetime. The outer lifetime is only a safety catch to make sure it does not live too long.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.OuterLifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.OuterLifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)">
            <summary>
            Exposes the <see cref="M:JetBrains.DataFlow.Lifetime.AttachNested(JetBrains.DataFlow.LifetimeDefinition,System.Boolean)" /> operation so that creation of nested lifetimes were possible on an outer lifetime.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SequentialLifetimes">
            <summary>
            Maintains a sequence of lifetimes, so that the previous lifetime is closed before the new one is opened.
            Good for implementing a sequence of non-simultaneous activities when it's nice to guarantee only one is active at a time.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.#ctor(JetBrains.DataFlow.Lifetime)">
            <summary>Creates and binds to the lifetime.</summary>
            <param name="lifetime">When this lifetime is closed, the last of the sequential lifetimes is closed too.</param>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.Next(System.Action{JetBrains.DataFlow.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.DefineNext(System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime})">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            The lifetime definition allows to terminate it as desired.
            Also, the lifetime will be terminated when either parent lifetime is terminated,
            or <see cref="M:JetBrains.DataFlow.SequentialLifetimes.TerminateCurrent"/> is called, or <see cref="M:JetBrains.DataFlow.SequentialLifetimes.DefineNext(System.Action{JetBrains.DataFlow.LifetimeDefinition,JetBrains.DataFlow.Lifetime})"/>/<see cref="M:JetBrains.DataFlow.SequentialLifetimes.Next"/> is called.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.TerminateCurrent">
            <summary>
            Terminates the current lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SequentialLifetimes.SetCurrentLifetime(JetBrains.DataFlow.LifetimeDefinition)">
            <summary>
            Atomically, assigns the new lifetime and terminates the old one.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemove">
            <summary>
            Defines whether the action is <see cref="F:JetBrains.DataFlow.AddRemove.Add"/> or <see cref="F:JetBrains.DataFlow.AddRemove.Remove"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.AddRemove.Add">
            <summary>
            Adding.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.AddRemove.Remove">
            <summary>
            Removing.
            </summary>
        </member>
    </members>
</doc>
