sourceSets {
    test {
        java.srcDir 'testSrc'
        resources.srcDir 'testData'
    }
}

def dependenciesDir = new File("dependencies")

intellij {
    pluginName 'rider-unity'
    type 'RD'

    // Download a version of Rider to compile and run with. Either set `version` to
    // 'LATEST-TRUNK-SNAPSHOT' or 'LATEST-EAP-SNAPSHOT' or a known version.
    // This will download from www.jetbrains.com/intellij-repository/snapshots or
    // www.jetbrains.com/intellij-repository/releases, respectively.
    // http://jetbrains-com-mirror.labs.intellij.net/intellij-repository/snapshots/
    // Note that there's no guarantee that these are kept up to date
    // version = 'LATEST-TRUNK-SNAPSHOT'
    // If the build isn't available in intellij-repository, use an installed version via `localPath`
    // localPath = '/Users/matt/Library/Application Support/JetBrains/Toolbox/apps/Rider/ch-1/171.4089.265/Rider EAP.app/Contents'
    // localPath = "F:\\RiderSDK"

    if (dependenciesDir .exists()) {
        localPath = dependenciesDir.absolutePath
    } else {
        version = "2018.2-SNAPSHOT"
    }
    
    intellijRepo = "https://cache-redirector.jetbrains.com/intellij-repository"

    // Sources aren't available for Rider
    downloadSources = false
}

task validatePluginXml {
    def pluginXml = new File(repoRoot, "rider/src/main/resources/META-INF/plugin.xml")
    assert pluginXml.isFile()

    def parsed = new XmlParser().parse(pluginXml).text()
    assert parsed.length() > 0

    def rawBytes = pluginXml.bytes
    assert rawBytes.length > 0

    def invalid = rawBytes.findAll { it < 0 }
    assert invalid.size() == 0

    logger.lifecycle("$pluginXml.path is valid XML and contains only US-ASCII symbols, bytes: $rawBytes.length")
}

def frontendSdkRoot = dependenciesDir
// bundled build configuration on TC
if (dependenciesDir.exists() && dependenciesDir.isDirectory()) {
    logger.lifecycle("dependencies dir found, using as frontend SDK root")    
}
else {
    def frontendSdkVersion = "2018.2-SNAPSHOT"
    def frontendSdkDirs = []
    def frontendSdkSearchPath = new File(repoRoot, "rider/build")

    if (frontendSdkDirs.size() > 0) {
        assert frontendSdkDirs.size() == 1

        def frontendSdkSingleDir = frontendSdkDirs.first()
        def match = frontendSdkSingleDir.name =~ /riderRD-(.+)/
        assert match.matches()

        frontendSdkVersion = match[0][1]
    }

    frontendSdkRoot = new File(frontendSdkSearchPath, "riderRD-$frontendSdkVersion")
}

ext.rdLibDirectory = new File(frontendSdkRoot, "lib/rd").canonicalFile

sourceCompatibility = 1.8
targetCompatibility = 1.8

compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

apply plugin: 'com.jetbrains.rdgen'

ext.modelDir = new File(repoRoot, "rider/protocol/src/main/kotlin/model")

// TODO: Add an msbuild task for this, too?
// Because we sometimes skip building the C# solutions (calling runIde from the C# IDE), we might
// get into the situation where we rebuild the protocol for .kt, but not .cs
// Maybe we should have an msbuild task to run rdgen if the input model .kt is newer than the output
// .cs. Or make sure we don't skip the msbuild tasks if this task runs

task generateRiderModel(type: RdGen) {
    def csOutput = new File(repoRoot, "resharper/src/resharper-unity/Rider/RdUnityProtocol")
    def ktOutput = new File(repoRoot, "rider/src/main/kotlin/com/jetbrains/rider/protocol/RdUnityProtocol")

    params {
        verbose = true
        classpath "$rdLibDirectory/rider-model.jar"
        sources "$modelDir/rider"
        hashFolder = 'build/rdgen/rider'
        packages = "model.rider"

        generator {
            language = "kotlin"
            transform = "asis"
            root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
            namespace = "com.jetbrains.rider.model"
            directory = "$ktOutput"
        }

        generator {
            language = "csharp"
            transform = "reversed"
            root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
            namespace = "JetBrains.Rider.Model"
            directory = "$csOutput"
        }

    }
}

task generateEditorPluginModel(type: RdGen) {
    params {
        verbose = true
        classpath "$rdLibDirectory/rider-model.jar"
        hashFolder = "build/rdgen/editorPlugin"
        sources "$modelDir/editorPlugin"
        packages = "model.editorPlugin"
    }
}

task generateModel {
    group = 'other'
    description = 'Generates protocol models.'
}

generateModel.dependsOn(generateRiderModel, generateEditorPluginModel)


// When running in CI, we call `gradle buildPlugin`
// When running interactively, we call `gradle runIde`
// When running from the open rider solution, we call `gradle runIde -PDotNetUpToDate=true`
//   to skip slow, no-op nuget restore and msbuild. Maybe .NET Core 2.1 will speed that up for us

// buildPlugin depends on prepareSandbox, then zips up the sandbox dir
// runIde depends on prepareSandbox, then executes IJ inside that dir
// prepareSandbox dependsOn standard java build/jar then copies everything to the sandbox dir

// When calling buildPlugin, we should build everything on the backend
// When calling runIde, we should only build Rider and the Unity editor
// prepareSandbox should also make sure that all of the Rider and Unity editor bits are copied
//   (who owns this, frontend, or backend?)


task publishCiBuildNumber {
    doLast {
        ci.SetBuildNumber(version)
    }
}

task publishCiBuildData {
    if (project.isBuildingUnderCi) {
        dependsOn publishCiBuildNumber
        dependsOn publishCiBackendArtifacts
    }
}

buildPlugin.finalizedBy publishCiBuildData
buildPlugin.dependsOn generateModel, validatePluginXml

// If we're building `runIde`, only build Rider bits. We only know this once the task graph
// has been evaluated. It's now too late to change inputs/outputs or dependencies. An alternative
// approach would be to set the appropriate tasks `enabled` flag
gradle.taskGraph.whenReady { taskGraph ->
    project.shouldBuildRiderOnly = (taskGraph.hasTask(runIde) && !taskGraph.hasTask(buildPlugin)) || (taskGraph.hasTask(buildRiderOnlyPlugin) && !taskGraph.hasTask(buildFullReSharperPlugin))
    logger.lifecycle("project.shouldBuildRiderOnly=$project.shouldBuildRiderOnly")
}

def dllFiles = [
    "../resharper/build/resharper-unity.rider/bin/$BuildConfiguration/net461/JetBrains.ReSharper.Plugins.Unity.dll",
    "../resharper/build/resharper-unity.rider/bin/$BuildConfiguration/net461/JetBrains.ReSharper.Plugins.Unity.pdb",
]

def annotationsFrom = '../resharper/src/resharper-unity/annotations'
def annotationsTo = 'Extensions/JetBrains.Unity/annotations'

def unityeditorplugin_path = "$projectDir/../unity/build/JetBrains.Rider.Unity.Editor.Plugin/Assets/Plugins/Editor/JetBrains/JetBrains.Rider.Unity.Editor.Plugin.Repacked.dll"
def unityeditorplugin_full_path = "$projectDir/../unity/build/JetBrains.Rider.Unity.Editor.Plugin.Full/Assets/Plugins/Editor/JetBrains/JetBrains.Rider.Unity.Editor.Plugin.Full.Repacked.dll"

prepareSandbox {
    // Already depends on the standard Java build/jar task
    dependsOn buildReSharperHostPlugin, buildUnityEditorPlugin

    // Have dependent tasks use uptodateWhen { project.isRunningUnderCi etc. }
    //inputs.files(buildRiderPlugin.outputs)
    //inputs.files(buildUnityEditorPlugin.packedPath)

    // Backend:
    // Copy unity editor plugin repacked file to `rider-unity/EditorPlugin`
    // Copy JetBrains.ReSharper.Plugins.Unity.dll to `rider-unity/dotnet`
    // Copy annotations to `rider-unity/dotnet/Extensions/JetBrains.Unity/annotations`

    // Frontend:
    // Copy projectTemplates to `rider-unity/projectTemplates`

    // Assert these files exist?

    doLast {
        assert file(unityeditorplugin_path).exists()
        assert file(unityeditorplugin_full_path).exists()

        dllFiles.forEach({ f ->
            def file = file("$f")
            if (!file.exists()) throw new RuntimeException("File $file does not exist")
        })
    }

    from(unityeditorplugin_path, {
        into "$intellij.pluginName/EditorPlugin"
    })

    from(unityeditorplugin_full_path, {
        into "$intellij.pluginName/EditorPlugin"
    })

    dllFiles.forEach({ f ->
        def file = file(f)
        from(file, { into "$intellij.pluginName/dotnet" })
    })

    from(annotationsFrom, { into "$intellij.pluginName/dotnet/$annotationsTo" })
    into("$intellij.pluginName/projectTemplates") {
        from 'projectTemplates'
    }
}

test {
    useTestNG() {}
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
    }
}
