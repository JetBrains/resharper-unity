def backendGroup = 'backend'

import org.apache.tools.ant.taskdefs.condition.Os

import java.util.regex.Matcher
import java.util.regex.Pattern

ext.backend = new BackendHelper(ext.repoRoot)

// Used to provide a package version to both msbuild and dotnet restore
ext.extraMSBuildArgs = []

class BackendHelper {
    File repositoryRoot
    File unityRoot
    File backendRoot
    File resharperHostPluginSolution
    File unityPluginSolution
    File unityPluginSingleProject   // For "rider only" configuration
    File riderTestsProject  // For "rider only" configuration

    BackendHelper(File repoRoot) {
        repositoryRoot = repoRoot
        assert repositoryRoot.isDirectory()

        backendRoot = new File(repositoryRoot, 'resharper')
        assert backendRoot.isDirectory()

        unityRoot = new File(repositoryRoot, 'unity')
        unityPluginSolution = new File(unityRoot, 'JetBrains.Rider.Unity.Editor/JetBrains.Rider.Unity.Editor.sln')
        unityPluginSingleProject = new File(unityRoot, 'JetBrains.Rider.Unity.Editor/EditorPlugin/EditorPlugin.csproj')

        resharperHostPluginSolution = new File(backendRoot, 'src/resharper-unity.sln')
        assert resharperHostPluginSolution.isFile()

        riderTestsProject = new File(backendRoot, 'test/src/tests.rider.csproj')
        assert riderTestsProject.isFile()
    }
}

class MSBuildTask extends DefaultTask {
    @InputFile
    File buildFile

    MSBuildTask() {
        onlyIf { !project.dotNetUpToDate }
    }

    // TODO: Set msbuild verbosity based on gradle log level

    @TaskAction
    def build() {
        project.ci.Progress("Building $buildFile ($project.BuildConfiguration)")

        def arguments = [ buildFile, "/p:Configuration=$project.BuildConfiguration", "/p:Version=$project.version", '/v:normal', '/nologo'] //, "/bl:${buildFile.name}.binlog" ]
        arguments.addAll(project.extraMSBuildArgs)
        project.exec {
            executable = findMSBuildPath()
            args = arguments
            standardOutput = System.out
        }
    }

    def findMSBuildPath() {
        if (project.ext.has('msbuildPath')) {
            logger.lifecycle("msbuildPath (cached): $project.msbuildPath")
            return project.msbuildPath
        }

        project.ext.msbuildPath = project.isWindows ? findMSBuildPathWindows() : findMSBuildPathUnix()
        logger.lifecycle "msbuildPath: $project.msbuildPath"
        return project.msbuildPath
    }

    def findMSBuildPathWindows() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = project.file(new File(project.backend.repositoryRoot, 'tools/vswhere.exe'))
            args = [ "-latest", "-products", "*", "-requires", "Microsoft.Component.MSBuild", "-property", "installationPath" ]
            standardOutput = stdout
        }

        def buildToolsDir = project.file(stdout.toString().trim())
        assert buildToolsDir.isDirectory()

        return project.file(new File(buildToolsDir, 'MSBuild/15.0/Bin/MSBuild.exe'))
    }

    def findMSBuildPathUnix() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = 'which'
            args = [ 'msbuild' ]
            standardOutput = stdout
        }

        return project.file(stdout.toString().trim())
    }
}

class MonoExecTask extends AbstractExecTask {
    MonoExecTask() {
        super(MonoExecTask.class)
    }

    @TaskAction
    protected void exec() {
        if (!project.isWindows) {
            def newCommandLine = [ 'mono' ]
            newCommandLine.addAll(commandLine)
            commandLine = newCommandLine
        }

        super.exec()
    }
}

class RestorePackagesTask extends DefaultTask {
    @InputFile
    File packagesFile

    RestorePackagesTask() {
        onlyIf { !project.dotNetUpToDate }
    }

    @TaskAction
    def restore() {
        project.ci.Progress("Restoring packages for $packagesFile")

        // TODO: Map verbosity to gradle logging verbosity
        def restoreArguments = [ 'restore', '--verbosity', 'normal' ]
        if (project.PackageSource != null) {
            restoreArguments << '--source' << 'https://api.nuget.org/v3/index.json'
            restoreArguments << '--source' << 'https://www.myget.org/F/jetbrains-rider-sdk-snapshots/api/v3/index.json'
            restoreArguments << '--source' << project.PackageSource
        }
        restoreArguments.addAll project.extraMSBuildArgs
        restoreArguments << packagesFile
        project.exec {
            executable = 'dotnet'
            args = restoreArguments
            standardOutput = System.out
        }
    }
}

task findLocalRiderSDKVersion {

    onlyIf { PackageSource != null }

    doLast {
        def directory = file(PackageSource)
        assert directory.isDirectory()

        def packageName = 'JetBrains.Rider.SDK'
        def escapedPackageName = Pattern.quote(packageName)

        logger.lifecycle("Looking for package $packageName in $directory")

        def packageVersion = directory.listFiles().collect { File f ->
            if (f.isFile()) {
                logger.trace(f.name)

                def match = (f.name =~ /^(?i)$escapedPackageName\.((\d+\.)+\d+((-eap|-snapshot)\d+(d?)(pre|internal)?)?)\.nupkg\u0024/)
                if (match.matches()) {
                    return match[0][1]
                }
            }

            return null
        }.find { String s -> s != null }

        assert packageVersion != null : 'No files found matching the package version regex'

        extraMSBuildArgs << "/p:RiderSDKVersion=$packageVersion"
    }
}

task prepareNuGetConfigWithPathToRiderSDK {
    def riderSdkPath = file(new File(repoRoot.canonicalPath, "rider/build/riderRD-2018.2-SNAPSHOT/lib/ReSharperHostSdk"))
    ci.Progress("Preparing NuGet config with frontend SDK path: $riderSdkPath")
    new File("$repoRoot/resharper/src/NuGet.Config").text = """<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="local-rider-sdk" value="$riderSdkPath" />
  </packageSources>
</configuration>
"""
}

task restoreUnityEditorPluginPackages(type: RestorePackagesTask) {
    group backendGroup
    description 'Restores packages for Unity Editor plugin'
    dependsOn findLocalRiderSDKVersion
    packagesFile backend.unityPluginSolution
}

task restoreReSharperHostPluginPackages(type: RestorePackagesTask) {
    group backendGroup
    description 'Restores packages for backend plugin'
    dependsOn findLocalRiderSDKVersion, prepareNuGetConfigWithPathToRiderSDK
    packagesFile backend.resharperHostPluginSolution
}


task buildFullReSharperPlugin(type: MSBuildTask) {
    group backendGroup
    description 'Builds the fill ReSharper backend plugin solution'
    dependsOn restoreReSharperHostPluginPackages

    onlyIf { !project.shouldBuildRiderOnly }

    buildFile = backend.resharperHostPluginSolution
}

task buildRiderOnlyPlugin(type: MSBuildTask) {
    group backendGroup
    description 'Builds the Rider plugin project'
    dependsOn restoreReSharperHostPluginPackages

    onlyIf { project.shouldBuildRiderOnly }

    buildFile = backend.riderTestsProject
}


task buildUnityEditorPluginFull(type: MSBuildTask) {
    group backendGroup
    description 'Builds full Unity editor plugin solution'
    dependsOn restoreUnityEditorPluginPackages

    onlyIf { !project.shouldBuildRiderOnly }

    buildFile = backend.unityPluginSolution
}

task buildUnityEditorPluginLight(type: MSBuildTask) {
    group backendGroup
    description 'Builds the Unity editor plugin project'
    dependsOn restoreUnityEditorPluginPackages

    onlyIf { project.shouldBuildRiderOnly }

    buildFile = backend.unityPluginSingleProject
}


task buildReSharperHostPlugin {
    group = backendGroup
    description = 'Build the ReSharper plugin for Rider and/or ReSharper'

    // We need to have two dependencies here. We want to change behaviour based on
    // which root level task we're executing, and we only know that at execution time.
    // The `buildPlugin` and `runIde` tasks will set the `shouldBuildRiderOnly` flag,
    // but only at execution time, not at configuration time. So we don't know what we're
    // building until we start building.
    // So, set up two tasks that are really only different in what project or solution
    // they build, and skip one of them at execution time by checking `shouldBuildRiderOnly`.
    // I can't think of a nicer way to have `prepareSandbox` depend on different tasks
    // based on what's executing
    dependsOn buildRiderOnlyPlugin, buildFullReSharperPlugin
}

task buildUnityEditorPlugin {
    group = backendGroup
    description = 'Build the Unity editor plugin'

    // See comment above
    dependsOn buildUnityEditorPluginLight, buildUnityEditorPluginFull
}


task packReSharperPlugin(type: MonoExecTask) {
    dependsOn buildReSharperHostPlugin
    group = backendGroup
    description = 'Packs resulting DLLs into a NuGet package which is an R# extension.'

    def nuspecFile = file(new File(backend.backendRoot, 'src/resharper-unity/resharper-unity.resharper.nuspec'))
    def outputDir = file(new File(backend.backendRoot, "build/resharper-unity.resharper/bin/$BuildConfiguration"))
    def nupkgFile = file(new File(outputDir, "JetBrains.Unity.${version}.nupkg"))

    // TODO: Make the output of the compile step the inputs of this step, as well as the nuspec
    // inputs.files(nuspecFile)
    outputs.files(nupkgFile)

    def nugetExe = file(new File(backend.repositoryRoot, 'tools/nuget.exe'))
    def arguments = [ 'pack', nuspecFile, '-NoPackageAnalysis', '-Properties', "Configuration=$BuildConfiguration", '-Version', "$version", '-OutputDirectory', outputDir ]

    executable = nugetExe
    args = arguments

    doFirst {
        ci.Progress("Packing: $nuspecFile.name")
    }
}

task publishCiBackendArtifacts {
    inputs.file(packReSharperPlugin.outputs)

    doLast {
        ci.PublishArtifact(packReSharperPlugin.outputs.files.singleFile)
    }
}
